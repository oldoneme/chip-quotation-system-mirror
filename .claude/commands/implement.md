# 实施功能

根据计划实施以下功能：$ARGUMENTS

## 实施前检查清单

### 📋 前置条件
- [ ] 已创建并审阅实施计划
- [ ] 理解所有相关代码
- [ ] 环境已正确配置
- [ ] 依赖已安装且版本正确
- [ ] 测试套件运行正常

### 🎯 明确目标
- [ ] 功能需求清晰明确
- [ ] 成功标准已定义
- [ ] 验收条件已确认
- [ ] 性能要求已了解

## 实施流程

### 第一步：环境准备
1. **拉取最新代码**
   ```bash
   git pull origin main
   git checkout -b feature/[功能名称]
   ```

2. **运行现有测试**
   ```bash
   npm test
   npm run lint
   npm run typecheck
   ```

3. **确认无破坏性改动**
   - 所有测试通过
   - 无 lint 错误
   - 类型检查通过

### 第二步：渐进式实施

#### 小步前进原则
每个改动都应该：
- ✅ 可独立编译
- ✅ 不破坏现有功能
- ✅ 有对应的测试
- ✅ 可以独立回滚

#### 实施顺序
1. **核心功能** - 最小可行实现
2. **边界处理** - 错误和异常情况  
3. **优化增强** - 性能和用户体验
4. **完善细节** - 日志、监控、文档

### 第三步：编码标准

#### 代码组织
```javascript
// 1. 导入依赖 - 按类型分组
import React from 'react';           // 外部库
import { util } from '@/utils';      // 内部工具
import { Component } from './local'; // 本地组件

// 2. 类型定义
interface Props {
  // ...
}

// 3. 主要实现
export function Feature() {
  // 3.1 状态和 hooks
  // 3.2 副作用
  // 3.3 事件处理
  // 3.4 渲染逻辑
}

// 4. 辅助函数
function helper() {
  // ...
}
```

#### 错误处理
```javascript
// 明确的错误处理
try {
  const result = await riskyOperation();
  return result;
} catch (error) {
  // 记录错误上下文
  logger.error('操作失败', {
    operation: 'riskyOperation',
    input: params,
    error: error.message
  });
  
  // 适当的错误恢复
  return fallbackValue;
}
```

### 第四步：持续验证

#### 每完成一个小功能后
1. **运行相关测试**
   ```bash
   npm test -- --watch [测试文件]
   ```

2. **检查代码质量**
   ```bash
   npm run lint:fix
   npm run format
   ```

3. **验证功能**
   - 手动测试主要路径
   - 检查边界条件
   - 验证错误处理

4. **提交改动**
   ```bash
   git add -p  # 交互式添加，审查每个改动
   git commit -m "feat: [清晰的提交信息]"
   ```

### 第五步：集成测试

#### 完整功能测试
- [ ] 所有单元测试通过
- [ ] 集成测试通过
- [ ] E2E 测试通过（如有）
- [ ] 性能基准测试

#### 兼容性检查
- [ ] 浏览器兼容性（如适用）
- [ ] API 版本兼容性
- [ ] 数据迁移（如需要）

## 实施原则

### ✅ 应该做的
1. **保持代码可工作** - 随时可以演示
2. **频繁提交** - 小步前进，易于回滚
3. **先简单后复杂** - 逐步增加复杂度
4. **及时重构** - 不积累技术债务
5. **充分测试** - 每个功能都有测试覆盖

### ❌ 不应该做的
1. **大爆炸式提交** - 一次改动太多文件
2. **破坏主分支** - 未测试就合并
3. **过度工程** - 添加不需要的抽象
4. **忽视警告** - Lint 和类型错误
5. **跳过测试** - 认为"这次没问题"

## 问题处理

### 遇到阻塞时
1. **执行三次尝试规则**
   - 尝试 1: 最直接的方案
   - 尝试 2: 调整参数或方法
   - 尝试 3: 完全不同的思路

2. **三次失败后重新评估**
   - [ ] 问题定义是否准确？
   - [ ] 是否缺少必要信息？
   - [ ] 是否需要分解任务？
   - [ ] 是否需要团队协助？

### 发现设计问题时
1. **停止编码**
2. **记录问题和可能的解决方案**
3. **评估影响范围**
4. **与团队讨论（如需要）**
5. **更新实施计划**

## 完成检查

### 功能完成标准
```yaml
代码:
  - [ ] 功能完整实现
  - [ ] 所有测试通过
  - [ ] 代码审查通过
  - [ ] 无 TODO 没有 issue

质量:
  - [ ] 符合编码规范
  - [ ] 性能达到要求
  - [ ] 安全性已考虑
  - [ ] 可访问性已处理

文档:
  - [ ] 代码注释完整
  - [ ] API 文档更新
  - [ ] README 更新
  - [ ] CHANGELOG 更新
```

### 交付准备
1. **创建 Pull Request**
   ```bash
   git push origin feature/[功能名称]
   # 在 GitHub 上创建 PR
   ```

2. **PR 描述模板**
   ```markdown
   ## 改动说明
   [简要描述这个 PR 做了什么]
   
   ## 改动类型
   - [ ] 新功能
   - [ ] Bug 修复
   - [ ] 重构
   - [ ] 文档
   
   ## 测试
   - [ ] 单元测试已添加/更新
   - [ ] 手动测试已完成
   
   ## 截图（如适用）
   [添加 UI 改动的截图]
   
   ## 相关 Issue
   Closes #[issue 编号]
   ```

## 记住

> "Working software is the primary measure of progress." - Agile Manifesto

实施的目标是交付可工作的软件，而不是完美的代码。保持：
- 🚀 持续交付价值
- 🔄 快速获取反馈
- 📈 渐进式改进
- 🛡️ 始终保持可工作状态
# backend/app/services/frontend_snapshot_pdf_service.py
from playwright.sync_api import sync_playwright
import os
import threading
from concurrent.futures import ThreadPoolExecutor
from urllib.parse import urlencode
import logging

logger = logging.getLogger(__name__)

FRONTEND_BASE_URL = os.getenv("FRONTEND_BASE_URL", "http://localhost:3000")
READY_SELECTOR = os.getenv("SNAPSHOT_READY_SELECTOR", "#quote-ready")

def _quote_detail_path(quote_number: str) -> str:
    # æ ¹æ®å®žé™…å‰ç«¯è·¯ç”±ä¿®æ”¹ - ä½¿ç”¨æ­£ç¡®çš„è·¯å¾„
    return f"/quote-detail/{quote_number}"

def _build_url(path: str, token: str | None):
    base = FRONTEND_BASE_URL.rstrip("/")
    if token:
        return f"{base}{path}?{urlencode({'__snapshot_token': token})}"
    return f"{base}{path}"

def _inject_auth(page, jwt_token: str | None, cookies: list[dict] | None):
    if jwt_token:
        page.set_extra_http_headers({"Authorization": f"Bearer {jwt_token}"})
    if cookies:
        page.context.add_cookies(cookies)

def _run_playwright_in_thread(
    quote_number: str,
    output_path: str,
    jwt_token: str | None = None,
    cookies: list[dict] | None = None,
    ready_selector: str | None = READY_SELECTOR,
) -> bytes:
    """åœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­è¿è¡ŒPlaywrightï¼Œé¿å…asyncioå†²çª"""
    with sync_playwright() as p:
        try:
            logger.info(f"ðŸ“¸ å¼€å§‹å‰ç«¯å¿«ç…§: {quote_number}")

            # åˆ›å»ºæ–°æµè§ˆå™¨å®žä¾‹
            browser = p.chromium.launch(
                headless=True,
                args=["--no-sandbox", "--disable-setuid-sandbox"]
            )

            context = browser.new_context()
            page = context.new_page()
            _inject_auth(page, jwt_token, cookies)

            url = _build_url(_quote_detail_path(quote_number), token=None)
            logger.info(f"ðŸŒ è®¿é—®URL: {url}")
            page.goto(url, wait_until="domcontentloaded", timeout=60000)

            # ç­‰å¾…å‰ç«¯æ¸²æŸ“å®Œæ¯•æ ‡è®°
            if ready_selector:
                logger.info(f"â³ ç­‰å¾…æ¸²æŸ“å®Œæˆæ ‡è®°: {ready_selector}")

                # è°ƒè¯•ï¼šæ£€æŸ¥é¡µé¢å†…å®¹
                try:
                    page.wait_for_load_state("domcontentloaded", timeout=10000)
                    # ç­‰å¾…ä¸€äº›åŸºæœ¬å†…å®¹åŠ è½½
                    page.wait_for_selector("body", timeout=10000)

                    # æ£€æŸ¥æ˜¯å¦æœ‰ä»»ä½•#quote-readyå…ƒç´ 
                    ready_elements = page.query_selector_all("#quote-ready")
                    logger.info(f"ðŸ” æ‰¾åˆ° {len(ready_elements)} ä¸ª #quote-ready å…ƒç´ ")

                    if ready_elements:
                        element = ready_elements[0]
                        visible = element.is_visible()
                        enabled = element.is_enabled()
                        logger.info(f"ðŸ” #quote-ready çŠ¶æ€: visible={visible}, enabled={enabled}")

                        # å°è¯•ç­‰å¾…å¯è§
                        if not visible:
                            logger.info("â³ #quote-readyå­˜åœ¨ä½†ä¸å¯è§ï¼Œç­‰å¾…å˜ä¸ºå¯è§...")
                            page.wait_for_selector(ready_selector, state="visible", timeout=60000)
                        else:
                            logger.info("âœ… #quote-readyå·²å¯è§!")
                    else:
                        logger.info("â³ #quote-readyå°šæœªåˆ›å»ºï¼Œç­‰å¾…åˆ›å»º...")
                        page.wait_for_selector(ready_selector, timeout=60000)

                except Exception as debug_e:
                    logger.warning(f"ðŸ” è°ƒè¯•æ£€æŸ¥å¤±è´¥: {debug_e}")
                    # å›žé€€åˆ°åŽŸå§‹ç­‰å¾…
                    page.wait_for_selector(ready_selector, timeout=60000)
            else:
                logger.info("â³ ç­‰å¾…ç½‘ç»œç©ºé—²")
                page.wait_for_load_state("networkidle", timeout=60000)

            logger.info("ðŸ–¨ï¸ å¼€å§‹ç”ŸæˆPDF")
            page.emulate_media(media="print")
            pdf_bytes = page.pdf(
                format="A4",
                margin={"top": "8mm","bottom":"8mm","left":"8mm","right":"8mm"},
                print_background=True,
            )

            os.makedirs(os.path.dirname(output_path), exist_ok=True)
            with open(output_path, "wb") as f:
                f.write(pdf_bytes)

            logger.info(f"âœ… å¿«ç…§æˆåŠŸ: {quote_number} size={len(pdf_bytes)} path={output_path}")
            return pdf_bytes

        except Exception as e:
            logger.error(f"âŒ å¿«ç…§å¤±è´¥: {quote_number} {str(e)}")
            raise
        finally:
            try:
                browser.close()
            except:
                pass

def generate_quote_pdf_from_frontend_snapshot_sync(
    quote_number: str,
    output_path: str,
    jwt_token: str | None = None,
    cookies: list[dict] | None = None,
    ready_selector: str | None = READY_SELECTOR,
) -> bytes:
    """åœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­è¿è¡ŒPlaywrightï¼Œé¿å…asyncioå†²çª"""
    with ThreadPoolExecutor(max_workers=1) as executor:
        future = executor.submit(
            _run_playwright_in_thread,
            quote_number,
            output_path,
            jwt_token,
            cookies,
            ready_selector
        )
        return future.result(timeout=120)  # 2åˆ†é’Ÿè¶…æ—¶

class FrontendSnapshotPdfService:
    def generate_quote_pdf_from_frontend_snapshot_sync(self, *args, **kwargs) -> bytes:
        return generate_quote_pdf_from_frontend_snapshot_sync(*args, **kwargs)

frontend_snapshot_pdf_service = FrontendSnapshotPdfService()